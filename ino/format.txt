- @nodemcu:first loop pub online&ready to odroid broker (, until it send disp/cmd , and will ack)
- @odroid : after odroid received ready=1 state, odroid pub 1st queue where status = pending via payload to nodemcu
- @nodemcu: set ready = 0; disp/ack then odroid server change queue.status = in_progress (from pending->in_progress) 
- hardware process (this process ignore all disp/cmd from odroid) (ready=0)
. . . (wait until patient pick the med from the box (detect with censor))
- @nodemcu: pub disp/evt back to odroid & ready = 1

# nodeId = {1,2}

# Topics (nodeId is 1 or 2): use disp/cmd/{nodeId} to target a specific NodeMCU
disp/cmd/{nodeId}    // Controller (server) → สั่งงาน NodeMCU (nodeId = 1|2)
*****************************************************************************************
    { "queue_id": <queueId>, "op": <device>, "id": <servoId>, "on": <1|0,on|off> }

        op = {servo | dc | step | pump}
    servoId = {1 | 2 | 3 | 4 | 5 | 6}    // nodeMCU1 = {1|2|3|4}, nodeMCU2 = {5|6}

 
disp/ack/{nodeId}    // Node → ตอบรับรับคำสั่ง (accepted)       queue<pending -> in_progress>
*****************************************************************************************
    { "queue_id": <queueId>, "accepted": <1|0> }


disp/evt/{nodeId}    // Node → แจ้ง “งานจบ” สำหรับ queue นั้น   queue<in_progress -> success>
*****************************************************************************************
    { "queue_id": <queueId>, "done": 1, "status": "success", "room": <roomId> }

        roomId = {1 | 2 | 3}


disp/state/{nodeId}  // Node → heartbeat / readiness (health snapshot)
*****************************************************************************************
        # Preferred payload examples (combined payload is recommended):
        { "online": 1 }                     // node is online (retained recommended)
        { "ready": 1 }                      // node is idle and ready to accept next pending queue
        { "online":1, "ready":1 }         // combined: presence + readiness (preferred)

        Notes:
        - Node should repeatedly publish the combined {online, ready, uptime} while it remains ready.
            This ensures the server sees the node as available even if a single ready event is missed.
        - The retained "online" message is useful for UI presence. The combined messages should be
            non-retained so the server treats them as live readiness events.

Flow (recommended):
 1. Node boots and publishes disp/state/{nodeId} {"online":1} (retained)
 2. When node is idle and able to accept work, publish disp/state/{nodeId} {"ready":1}
 3. Server receives ready and publishes next pending queue to disp/cmd/{nodeId}
 4. Node receives command, publishes disp/ack/{nodeId} {"queue_id":..., "accepted":1}
 5. Node performs the work (NodeMCU coordinates Arduino) and when finished publishes disp/evt/{nodeId} {"queue_id":..., "done":1, "status":"success", "room":<roomId>}
 6. Node may wait a short delay, then publish disp/state/{nodeId} {"ready":1} again to receive the next queue





Roles and hardware notes

- NodeMCU (ESP8266/ESP32) role: orchestration / network interface. It subscribes to MQTT (disp/cmd/{nodeId}), parses commands, and sends simple logic signals (GPIO 0/1) to the downstream Arduino. NodeMCU should NOT directly drive high-current motors unless you know the power/driver arrangement.

- Arduino role: local controller. Receives logic-level signals from NodeMCU and drives the actuators (servos, DC motor drivers, stepper drivers, pumps) using proper drivers and power supplies.

Hardware notes:

- Avoid D8 (GPIO15) on NodeMCU if uncertain about boot mode.
- D3/D4 have pull-ups and are safer to use as outputs after boot.
- Servos accept 3.3V signal but servo/motor power must be 5–12V separate supply; share GND.

NodeMCU -> Arduino wiring (logic interface)
------------------------------------------------
Connect NodeMCU outputs (logic-only) to Arduino digital inputs. Use this mapping for NodeMCU1 -> Arduino1:

    NodeMCU (ESP)      Function / Signal        Arduino (controller)
    ------------------  ------------------------  -----------------
    D1 (GPIO5)         servo1_signal (logic)     Arduino D2 (PIN_IN_SERVO1)
    D2 (GPIO4)         servo2_signal (logic)     Arduino D3 (PIN_IN_SERVO2)
    D5 (GPIO14)        servo3_signal (logic)     Arduino D4 (PIN_IN_SERVO3)
    D6 (GPIO12)        servo4_signal (logic)     Arduino D5 (PIN_IN_SERVO4)
    D7 (GPIO13)        dcmotor1_enable (logic)   Arduino D6 (PIN_IN_DC_EN)

Wiring notes:
- Shared ground: always connect NodeMCU GND <-> Arduino GND.
- Signal levels: NodeMCU outputs 3.3V which Arduino digital inputs read as HIGH. If you use 5V logic boards on the MCU side, use level shifting.
- Pull mode: NodeMCU actively drives lines HIGH/LOW. Configure Arduino pins as INPUT (no internal pull-ups) and rely on NodeMCU drive state. If you prefer pull-ups, wire and invert logic consistently.
- Safety: DO NOT connect motor power to MCU pins. Motor drivers should have their own supply with common GND; Arduino drives the driver inputs.

#nodemcu1 — 5 pins รวม: servo1–4 = 4 pins, dcmotor1 = 1 pin

    servo1 → D1 (GPIO5)

    servo2 → D2 (GPIO4)

    servo3 → D5 (GPIO14)

    servo4 → D6 (GPIO12)

    dcmotor1_enable → D7 (GPIO13) (1 = หมุน, 0 = หยุด; ทิศคงที่ตามการต่อไดรเวอร์)

        คำสั่งตัวอย่าง (publish → disp/cmd/{nodeId}):

            ปล่อยยาเม็ดชนิด 2 (ไป nodemcu1): { "queue_id":123, "op":"servo", "id":2, "on":1 }

            เปิดสายพาน (nodemcu1): { "queue_id":123, "op":"dc", "on":1 }

            หยุดสายพาน (เมื่อ nodemcu2 success): { "queue_id":123, "op":"dc", "on":0 }


#nodemcu2 — ต้องการ 6 pins “stepmotor ซ้าย/ขวา”

dcmotor2_enable → D5 (GPIO14)

    pump → D6 (GPIO12)

    servo5 → D1 (GPIO5)

    servo6 → D2 (GPIO4)

    step_STEP → D7 (GPIO13)

    step_DIR → D3 (GPIO0) หรือ D4 (GPIO2) (เลือกอย่างใดอย่างหนึ่ง)

        คำสั่งตัวอย่าง (publish → disp/cmd/{nodeId}):

            เปิด dcmotor2 (nodemcu2): { "queue_id":123, "op":"dc", "on":1 }

            เปิด pump (nodemcu2): { "queue_id":123, "op":"pump", "on":1 }

            ตั้ง servo5 (nodemcu2 -> arduino): { "queue_id":123, "op":"servo", "id":5, "on":1 }

            หมุนสเต็ปไปทางขวา (ห้อง 2/3, nodemcu2): { "queue_id":123, "op":"step", "dir":"R" }

            หมุนสเต็ปไปทางซ้าย (ห้อง 1, nodemcu2): { "queue_id":123, "op":"step", "dir":"L" }

Note: NodeMCU only sends logic signals to Arduino (e.g. digitalWrite HIGH/LOW). The detailed actuator control (PWM, step pulses) is implemented on the Arduino side.